# 機能仕様書: fast-sql SQLite最適化ラッパーライブラリ

**機能ID**: `SPEC-aa9bcffb`
**作成日**: 2025-12-08
**ステータス**: 下書き
**入力**: ユーザー説明: "sql.jsを高速化した置き換え可能なライブラリを設計したい"

## ユーザーシナリオ＆テスト *(必須)*

### ユーザーストーリー1 - npx実行時のタイムアウト解消 (優先度: P1)

MCPサーバーを`npx`で実行する際に、ネイティブモジュールのビルドによる30秒タイムアウト問題を解消したい。ビルド不要なWASMベースのSQLite実装を使用することで、即座に起動できるようにする。

**この優先度の理由**: 現在の最大の課題であり、これが解決されないとMCPサーバーの`npx`実行が実用的でない。ユーザー体験に直接影響する最重要課題。

**独立テスト**: `npx @akiojin/unity-cli`を実行し、10秒以内にサーバーが起動することで検証可能。ネイティブビルドなしで動作することを確認。

**受け入れシナリオ**:

1. **前提** MCPサーバーがfast-sqlを使用して実装されている、**実行** `npx @akiojin/unity-cli`を実行、**結果** ネイティブモジュールのビルドなしで10秒以内にサーバーが起動する
2. **前提** 新しい環境（node_modulesなし）でMCPサーバーを実行、**実行** `npx @akiojin/unity-cli`を実行、**結果** 依存関係のダウンロード後、追加のビルドステップなしでサーバーが起動する

---

### ユーザーストーリー2 - sql.js互換APIの提供 (優先度: P1)

既存のsql.jsを使用しているコードを最小限の変更で移行できるよう、sql.js互換のAPIを提供する。開発者は既存のコードをほぼそのまま使用できる。

**この優先度の理由**: 既存のbetter-sqlite3/sql.jsコードからの移行を容易にするために、互換性のあるAPIは必須。移行コストが高いと採用されない。

**独立テスト**: sql.jsの基本的なAPIメソッド（exec、run、prepare、export、close）が同じシグネチャで動作することを確認。

**受け入れシナリオ**:

1. **前提** sql.jsを使用した既存コードがある、**実行** importをfast-sqlに変更、**結果** exec/run/prepareメソッドが同じ引数・戻り値で動作する
2. **前提** sql.jsでPreparedStatementを使用するコードがある、**実行** fast-sqlに切り替え、**結果** prepare/bind/step/get/resetが同じように動作する

---

### ユーザーストーリー3 - パフォーマンス最適化 (優先度: P2)

sql.js素の実装と比較して、20%以上のパフォーマンス改善を実現する。PRAGMA最適化、PreparedStatementキャッシュ、トランザクション最適化により実用的な速度を確保する。

**この優先度の理由**: ビルド不要であることが第一だが、パフォーマンスが著しく劣化すると実用性が損なわれる。better-sqlite3と同等でなくとも、実用的な速度が必要。

**独立テスト**: 50,000件のバルク挿入、同一SQLの反復クエリ、LIKE検索でsql.js素と比較したベンチマークを実行。

**受け入れシナリオ**:

1. **前提** 50,000件のレコードを挿入する、**実行** バルク挿入APIを使用、**結果** sql.js素（126ms）と比較して100ms以下で完了（20%以上改善）
2. **前提** 同一SQLを1000回反復実行する、**実行** 同じprepare済みステートメントで実行、**結果** sql.js素（21μs/回）と比較して10μs以下で実行（50%以上改善）

---

### ユーザーストーリー4 - 拡張APIの提供 (優先度: P3)

バルク操作やトランザクション管理など、パフォーマンスに影響する操作を簡単に行える拡張APIを提供する。開発者は最適化を意識せずに高速な操作を実行できる。

**この優先度の理由**: sql.js互換APIで基本機能は満たされるが、より効率的な操作のための拡張APIがあると便利。ただし必須ではない。

**独立テスト**: bulkInsert、transaction、getCacheStatsメソッドが正常に動作することを確認。

**受け入れシナリオ**:

1. **前提** 大量のレコードを挿入したい、**実行** `db.bulkInsert(sql, rows)`を使用、**結果** 自動的にトランザクション化され、1000件ごとにコミットされる
2. **前提** 複数の操作を原子的に実行したい、**実行** `db.transaction(() => { ... })`を使用、**結果** 全操作が成功するか、全て取り消される

---

### エッジケース

- **空のデータベース**: 空のデータベースを作成・エクスポートした場合、有効なSQLiteバイナリが生成される
- **大量データ**: 100万件を超えるレコードの処理時、メモリ不足を適切にハンドリングする
- **同時アクセス**: 同一インスタンスへの同時アクセス時、データ破損が発生しない
- **無効なSQL**: 構文エラーのあるSQLを実行した場合、適切なエラーメッセージが返される

## 要件 *(必須)*

### 機能要件

- **FR-001**: システムはsql.jsと互換性のあるAPIを提供する必要がある（exec、run、prepare、export、close）
- **FR-002**: システムはPreparedStatementをキャッシュし、同一SQLの再prepare時にキャッシュから返す必要がある
- **FR-003**: システムは起動時にPRAGMA最適化を自動適用する必要がある
- **FR-004**: システムはトランザクションを自動管理し、バルク操作を最適化する必要がある
- **FR-005**: システムはメモリDBとファイルDBの両方をサポートする必要がある
- **FR-006**: システムはデータベースのエクスポート（バイナリ形式）をサポートする必要がある
- **FR-007**: ユーザーはPRAGMA設定をカスタマイズできる必要がある
- **FR-008**: ユーザーはキャッシュサイズとTTLを設定できる必要がある

### 非機能要件

- **NFR-001**: MCPサーバーは`npx`実行時、MCPの初期化ハンドシェイク（`initialize`応答と最初の`tools/list`応答）までを10秒以内に完了する必要がある

### 主要エンティティ

- **Database**: SQLiteデータベースを表す。接続状態、PRAGMA設定、キャッシュを保持
- **Statement**: PreparedStatementを表す。バインドパラメータ、実行状態を保持
- **StatementCache**: PreparedStatementのキャッシュを管理。LRUアルゴリズムで古いエントリを削除
- **Backend**: 実際のSQLite実装（sql.js等）を抽象化したインターフェース

---

## スコープ外 *(オプション)*

以下の機能は本仕様のスコープ外とし、将来のバージョンで対応予定:

- better-sqlite3バックエンドの実装（環境に応じた自動選択）
- wa-sqliteバックエンドの実装
- Worker Thread内での非同期実行
- IndexedDB/OPFSへの永続化（ブラウザ環境向け）
- カスタムSQL関数の登録（create_function）
- 集計関数の登録（create_aggregate）

---

## 技術制約 *(該当する場合)*

- Node.js 18以上が必要
- WASMをサポートする環境が必要
- メモリDB使用時は使用可能メモリに依存

---

## 前提条件 *(該当する場合)*

この機能は以下を前提とします:

- sql.jsが正常に動作する環境
- ES Modules（ESM）をサポートするNode.js環境
- TypeScript 5.0以上（型定義を使用する場合）

---

## 依存関係 *(該当する場合)*

この機能は以下に依存します:

- sql.js（WASMベースのSQLite実装）

---

## 成功基準 *(必須)*

以下の成功基準を満たす必要があります:

1. MCPサーバーが`npx`実行時に10秒以内に起動する（ネイティブビルド不要）
2. sql.js互換APIがすべての基本操作（exec/run/prepare/export/close）で正常動作する
3. 50,000件バルク挿入がsql.js素と比較して20%以上高速（126ms → 100ms以下）
4. 同一SQL反復実行がsql.js素と比較して50%以上高速（21μs → 10μs以下）
5. 既存のcodeIndex.jsをfast-sqlに移行した際、動作が正常で性能劣化がない
