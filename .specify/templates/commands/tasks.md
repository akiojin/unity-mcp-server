---
description: 利用可能な設計アーティファクトに基づいて、実行可能で依存関係順に並んだ tasks.md を生成します。
handoffs:
  - label: 整合性分析
    agent: speckit.analyze
    prompt: プロジェクトの整合性分析を実行
    send: true
  - label: 実装開始
    agent: speckit.implement
    prompt: フェーズごとに実装を開始
    send: true
scripts:
  sh: .specify/scripts/bash/check-prerequisites.sh --json
  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json
---

## ユーザー入力

```text
$ARGUMENTS
```

空でない場合、続行する前にユーザー入力を考慮する**必要があります**。

## 実行手順

1. **セットアップ**: `{SCRIPT}` をリポジトリルートから実行し、`FEATURE_DIR` と `AVAILABLE_DOCS` リストを取得（パスはすべて絶対パス）。
   - シングルクォートを含む引数は適切にエスケープ

2. **設計ドキュメント読み込み**: FEATURE_DIR から:
   - **必須**: plan.md（技術スタック、ライブラリ、構造）, spec.md（優先度付きユーザーストーリー）
   - **任意**: data-model.md（エンティティ）, contracts/（APIエンドポイント）, research.md（決定事項）, quickstart.md（テストシナリオ）
   - 注意: すべてのドキュメントがあるとは限らない。利用可能なものに基づいてタスクを生成

3. **タスク生成ワークフロー**:
   - plan.md から技術スタック、ライブラリ、プロジェクト構造を抽出
   - spec.md からユーザーストーリーと優先度（P1, P2, P3...）を抽出
   - data-model.md があれば: エンティティを抽出しユーザーストーリーにマッピング
   - contracts/ があれば: エンドポイントをユーザーストーリーにマッピング
   - research.md があれば: セットアップタスク用の決定事項を抽出
   - ユーザーストーリーごとにタスクを生成（下記ルール参照）
   - ユーザーストーリーの完了順序を示す依存グラフを生成
   - ストーリーごとの並列実行例を作成
   - タスクの完全性を検証（各ストーリーに必要なタスクがあり、独立してテスト可能）

4. **tasks.md生成**: `templates/tasks-template.md` を構造として使用:
   - plan.md から正しい機能名
   - Phase 1: セットアップタスク（プロジェクト初期化）
   - Phase 2: 基盤タスク（全ユーザーストーリーのブロッキング前提条件）
   - Phase 3+: ユーザーストーリーごとに1フェーズ（spec.md の優先度順）
   - 各フェーズに: ストーリー目標、独立テスト基準、テスト（要求時）、実装タスク
   - 最終フェーズ: ポリッシュと横断的関心事
   - すべてのタスクは厳密なチェックリスト形式に従う（下記参照）
   - 各タスクに明確なファイルパス
   - ストーリー完了順序を示す依存関係セクション
   - ストーリーごとの並列実行例
   - 実装戦略セクション（MVP優先、インクリメンタルデリバリー）

5. **報告**: 生成した tasks.md のパスとサマリー:
   - 総タスク数
   - ユーザーストーリーごとのタスク数
   - 特定された並列化機会
   - 各ストーリーの独立テスト基準
   - MVP提案スコープ（通常はユーザーストーリー1のみ）
   - フォーマット検証: すべてのタスクがチェックリスト形式に従っていることを確認

タスク生成のコンテキスト: {ARGS}

tasks.md は即座に実行可能であるべき - 各タスクは追加コンテキストなしでLLMが完了できる具体性を持つこと。

## タスク生成ルール

**重要**: タスクはユーザーストーリーごとに整理し、独立した実装とテストを可能にする。

**テストは任意**: 機能仕様で明示的に要求されるか、ユーザーがTDDアプローチを要求した場合のみテストタスクを生成。

### チェックリスト形式（必須）

すべてのタスクは以下の形式に厳密に従う:

```text
- [ ] [TaskID] [P?] [Story?] ファイルパスを含む説明
```

**形式コンポーネント**:

1. **チェックボックス**: 常に `- [ ]`（Markdownチェックボックス）で開始
2. **タスクID**: 実行順の連番（T001, T002, T003...）
3. **[P]マーカー**: 並列化可能な場合のみ（異なるファイル、未完了タスクへの依存なし）
4. **[Story]ラベル**: ユーザーストーリーフェーズタスクのみ必須
   - 形式: [US1], [US2], [US3]... (spec.md のユーザーストーリーにマッピング)
   - セットアップフェーズ: ストーリーラベルなし
   - 基盤フェーズ: ストーリーラベルなし
   - ユーザーストーリーフェーズ: ストーリーラベル必須
   - ポリッシュフェーズ: ストーリーラベルなし
5. **説明**: 正確なファイルパスを含む明確なアクション

**例**:

- ✅ 正しい: `- [ ] T001 実装計画に従ってプロジェクト構造を作成`
- ✅ 正しい: `- [ ] T005 [P] src/middleware/auth.py に認証ミドルウェアを実装`
- ✅ 正しい: `- [ ] T012 [P] [US1] src/models/user.py に User モデルを作成`
- ✅ 正しい: `- [ ] T014 [US1] src/services/user_service.py に UserService を実装`
- ❌ 間違い: `- [ ] User モデルを作成` (IDとストーリーラベルがない)
- ❌ 間違い: `T001 [US1] モデル作成` (チェックボックスがない)
- ❌ 間違い: `- [ ] [US1] User モデル作成` (タスクIDがない)
- ❌ 間違い: `- [ ] T001 [US1] モデル作成` (ファイルパスがない)

### タスク整理

1. **ユーザーストーリーから（spec.md）** - 主要な整理軸:
   - 各ユーザーストーリー（P1, P2, P3...）が独自のフェーズを持つ
   - 関連コンポーネントをストーリーにマッピング:
     - そのストーリーに必要なモデル
     - そのストーリーに必要なサービス
     - そのストーリーに必要なエンドポイント/UI
     - テスト要求時: そのストーリー固有のテスト
   - ストーリーの依存関係をマーク（ほとんどのストーリーは独立すべき）

2. **コントラクトから**:
   - 各コントラクト/エンドポイント → サービス対象のユーザーストーリーにマッピング
   - テスト要求時: 各コントラクト → そのストーリーフェーズ内の実装前にコントラクトテストタスク [P]

3. **データモデルから**:
   - 各エンティティを必要とするユーザーストーリーにマッピング
   - 複数ストーリーで使用: 最初のストーリーまたはセットアップフェーズに配置
   - 関係 → 適切なストーリーフェーズのサービスレイヤータスク

4. **セットアップ/インフラから**:
   - 共有インフラ → セットアップフェーズ（Phase 1）
   - 基盤/ブロッキングタスク → 基盤フェーズ（Phase 2）
   - ストーリー固有のセットアップ → そのストーリーフェーズ内

### フェーズ構造

- **Phase 1**: セットアップ（プロジェクト初期化）
- **Phase 2**: 基盤（ブロッキング前提条件 - ユーザーストーリー前に完了必須）
- **Phase 3+**: ユーザーストーリー（優先度順: P1, P2, P3...）
  - 各ストーリー内: テスト（要求時）→ モデル → サービス → エンドポイント → 統合
  - 各フェーズは完全で独立してテスト可能なインクリメント
- **最終フェーズ**: ポリッシュと横断的関心事
