name: Auto Merge PR

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  required-checks:
    name: Required Checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Wait for required checks
        id: wait-required
        uses: actions/github-script@v7
        with:
          script: |
            const coreLib = core;
            const { owner, repo } = context.repo;
            const pullNumber = context.payload.pull_request.number;
            const maxAttempts = 40;
            const delayMs = 15000;

            const query = `
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $number) {
                    commits(last: 1) {
                      nodes {
                        commit {
                          statusCheckRollup {
                            contexts(first: 100) {
                              nodes {
                                __typename
                                ... on CheckRun {
                                  name
                                  status
                                  conclusion
                                  detailsUrl
                                  isRequired(pullRequestNumber: $number)
                                }
                                ... on StatusContext {
                                  context
                                  state
                                  targetUrl
                                  isRequired(pullRequestNumber: $number)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            function normalize(node) {
              if (!node?.isRequired) {
                return null;
              }

              if (node.__typename === 'CheckRun') {
                return {
                  type: 'CheckRun',
                  name: node.name,
                  status: node.status || 'UNKNOWN',
                  conclusion: node.conclusion || null,
                  detailsUrl: node.detailsUrl || null
                };
              }

              return {
                type: 'StatusContext',
                name: node.context,
                status: node.state || 'UNKNOWN',
                conclusion: node.state || 'UNKNOWN',
                detailsUrl: node.targetUrl || null
              };
            }

            async function fetchRequired() {
              const data = await github.graphql(query, { owner, repo, number: pullNumber });
              const nodes = data.repository?.pullRequest?.commits?.nodes ?? [];
              const latest = nodes[nodes.length - 1];
              const contexts = latest?.commit?.statusCheckRollup?.contexts?.nodes ?? [];
              return contexts.map(normalize).filter(Boolean);
            }

            const summarize = (contexts) => contexts.map((ctx) => ({
              type: ctx.type,
              name: ctx.name,
              status: ctx.status,
              conclusion: ctx.conclusion,
              detailsUrl: ctx.detailsUrl
            }));

            function isPending(ctx) {
              if (ctx.type === 'CheckRun') {
                return (ctx.status || '').toUpperCase() !== 'COMPLETED';
              }
              const state = (ctx.status || '').toUpperCase();
              return state === 'PENDING' || state === 'EXPECTED';
            }

            function isFailure(ctx) {
              if (ctx.type === 'CheckRun') {
                if ((ctx.status || '').toUpperCase() !== 'COMPLETED') {
                  return false;
                }

                const conclusion = (ctx.conclusion || '').toUpperCase();
                return conclusion && !['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(conclusion);
              }

              const state = (ctx.status || '').toUpperCase();
              return state === 'ERROR' || state === 'FAILURE';
            }

            let attempt = 0;
            let latestContexts = [];

            while (attempt < maxAttempts) {
              latestContexts = await fetchRequired();

              if (latestContexts.length === 0) {
                coreLib.info('No required checks configured; proceeding.');
                const result = { state: 'no_required_checks', contexts: [] };
                coreLib.setOutput('result', JSON.stringify(result));
                return result;
              }

              const failures = latestContexts.filter(isFailure);
              if (failures.length > 0) {
                const result = {
                  state: 'failed',
                  contexts: summarize(latestContexts),
                  failures: summarize(failures)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                coreLib.setFailed('Required checks failed.');
                return result;
              }

              const pending = latestContexts.filter(isPending);
              if (pending.length === 0) {
                const result = {
                  state: 'passed',
                  contexts: summarize(latestContexts)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                return result;
              }

              attempt += 1;
              coreLib.info(`Waiting for required checks to complete (attempt ${attempt}/${maxAttempts})...`);
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            }

            const result = {
              state: 'timeout',
              contexts: summarize(latestContexts)
            };
            coreLib.setOutput('result', JSON.stringify(result));
            coreLib.setFailed('Timed out waiting for required checks.');
            return result;

      - name: Comment on PR (Success)
        if: success()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{"contexts":[]}');
            const lines = result.contexts?.map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const icon = ['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(status) ? '✅' : 'ℹ️';
              const name = ctx.name || 'Unnamed check';
              return `${icon} ${name}: ${status}`;
            }) || [];

            const body = [
              '✅ **All required checks passed!**',
              '',
              lines.length ? lines.join('\n') : '- No required checks configured on the target branch.',
              '',
              'The PR is ready to be merged automatically.'
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Comment on PR (Failure)
        if: failure()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{}');
            const failing = (result.failures || []).map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const name = ctx.name || 'Unnamed check';
              return `❌ ${name}: ${status}`;
            });

            const body = [
              '❌ **Required checks failed!**',
              '',
              failing.length ? failing.join('\n') : '- Unable to identify failing required checks.',
              '',
              `Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

  auto-merge:
    name: Auto Merge
    needs: required-checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Merge PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "Attempting to merge PR #${{ github.event.pull_request.number }} with a merge commit..."
          gh pr merge ${{ github.event.pull_request.number }} --merge --yes --delete-branch=false

      - name: Comment on merge failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ **Auto-merge failed!**\n\nGitHub refused to merge the PR automatically. This usually happens if required conversations remain unresolved or branch protection checks are not satisfied. Please resolve the outstanding items and try again.'
            })

      - name: Comment on automatic merge
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ **PR automatically merged!**\n\nAll required checks passed and GitHub confirmed the merge into the main branch.'
            })
