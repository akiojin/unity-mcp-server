name: Auto Merge PR

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  required-checks:
    name: Required Checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Wait for required checks
        id: wait-required
        uses: actions/github-script@v7
        with:
          script: |
            const coreLib = core;
            const { owner, repo } = context.repo;
            const pullNumber = context.payload.pull_request.number;
            const baseBranch = context.payload.pull_request.base.ref;
            const maxAttempts = 40;
            const delayMs = 15000;

            async function loadRequiredContexts(branch) {
              try {
                const response = await github.request('GET /repos/{owner}/{repo}/branches/{branch}/protection', {
                  owner,
                  repo,
                  branch
                });
                const contexts = response.data?.required_status_checks?.contexts ?? [];
                return Array.from(new Set(contexts.filter(Boolean)));
              } catch (error) {
                if (error.status === 404) {
                  coreLib.info(`Branch ${branch} has no protection rule; treating as no required checks.`);
                  return [];
                }
                throw error;
              }
            }

            let requiredNames = [];
            try {
              requiredNames = await loadRequiredContexts(baseBranch);
            } catch (error) {
              const message = error?.message || 'unknown error';
              coreLib.setFailed(`Failed to load branch protection for ${baseBranch}: ${message}`);
              return;
            }

            if (requiredNames.length === 0) {
              coreLib.info('No required checks configured; proceeding.');
              const result = { state: 'no_required_checks', contexts: [] };
              coreLib.setOutput('result', JSON.stringify(result));
              return result;
            }

            const requiredSet = new Set(requiredNames);

            const query = `
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $number) {
                    commits(last: 1) {
                      nodes {
                        commit {
                          statusCheckRollup {
                            contexts(first: 100) {
                              nodes {
                                __typename
                                ... on CheckRun {
                                  name
                                  status
                                  conclusion
                                  detailsUrl
                                }
                                ... on StatusContext {
                                  context
                                  state
                                  targetUrl
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            function normalize(node) {
              if (!node) {
                return null;
              }

              if (node.__typename === 'CheckRun') {
                const name = node.name || 'Unnamed check';
                return {
                  type: 'CheckRun',
                  name,
                  key: name,
                  status: node.status || 'UNKNOWN',
                  conclusion: node.conclusion || null,
                  detailsUrl: node.detailsUrl || null
                };
              }

              if (node.__typename === 'StatusContext') {
                const name = node.context || 'Unnamed status';
                const state = node.state || 'UNKNOWN';
                return {
                  type: 'StatusContext',
                  name,
                  key: name,
                  status: state,
                  conclusion: state,
                  detailsUrl: node.targetUrl || null
                };
              }

              return null;
            }

            const summarize = (contexts) => contexts.map((ctx) => ({
              type: ctx.type,
              name: ctx.name,
              status: ctx.status,
              conclusion: ctx.conclusion,
              detailsUrl: ctx.detailsUrl
            }));

            function isPending(ctx) {
              if (!ctx) {
                return false;
              }

              if (ctx.type === 'CheckRun') {
                return (ctx.status || '').toUpperCase() !== 'COMPLETED';
              }

              if (ctx.type === 'StatusContext') {
                const state = (ctx.status || '').toUpperCase();
                return state === 'PENDING' || state === 'EXPECTED';
              }

              if (ctx.type === 'Pending') {
                return true;
              }

              return false;
            }

            function isFailure(ctx) {
              if (!ctx) {
                return false;
              }

              if (ctx.type === 'CheckRun') {
                if ((ctx.status || '').toUpperCase() !== 'COMPLETED') {
                  return false;
                }

                const conclusion = (ctx.conclusion || '').toUpperCase();
                return conclusion && !['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(conclusion);
              }

              if (ctx.type === 'StatusContext') {
                const state = (ctx.status || '').toUpperCase();
                return state === 'ERROR' || state === 'FAILURE';
              }

              return false;
            }

            async function fetchRequired(requiredNamesList) {
              const data = await github.graphql(query, { owner, repo, number: pullNumber });
              const nodes = data.repository?.pullRequest?.commits?.nodes ?? [];
              const latest = nodes[nodes.length - 1];
              const contexts = latest?.commit?.statusCheckRollup?.contexts?.nodes ?? [];

              const byName = new Map();

              for (const raw of contexts) {
                const normalized = normalize(raw);
                if (!normalized) {
                  continue;
                }
                if (requiredSet.has(normalized.key)) {
                  byName.set(normalized.key, normalized);
                }
              }

              return requiredNamesList.map((name) => {
                if (byName.has(name)) {
                  return byName.get(name);
                }
                return {
                  type: 'Pending',
                  name,
                  key: name,
                  status: 'PENDING',
                  conclusion: null,
                  detailsUrl: null
                };
              });
            }

            let attempt = 0;
            let latestContexts = [];

            while (attempt < maxAttempts) {
              latestContexts = await fetchRequired(requiredNames);

              const failures = latestContexts.filter(isFailure);
              if (failures.length > 0) {
                const result = {
                  state: 'failed',
                  contexts: summarize(latestContexts),
                  failures: summarize(failures)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                coreLib.setFailed('Required checks failed.');
                return result;
              }

              const pending = latestContexts.filter(isPending);
              if (pending.length === 0) {
                const result = {
                  state: 'passed',
                  contexts: summarize(latestContexts)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                return result;
              }

              attempt += 1;
              coreLib.info(`Waiting for required checks to complete (attempt ${attempt}/${maxAttempts})...`);
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            }

            const result = {
              state: 'timeout',
              contexts: summarize(latestContexts)
            };
            coreLib.setOutput('result', JSON.stringify(result));
            coreLib.setFailed('Timed out waiting for required checks.');
            return result;

      - name: Comment on PR (Success)
        if: success()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{"contexts":[]}');
            const lines = result.contexts?.map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const icon = ['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(status) ? '✅' : 'ℹ️';
              const name = ctx.name || 'Unnamed check';
              return `${icon} ${name}: ${status}`;
            }) || [];

            const body = [
              '✅ **All required checks passed!**',
              '',
              lines.length ? lines.join('\n') : '- No required checks configured on the target branch.',
              '',
              'The PR is ready to be merged automatically.'
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Comment on PR (Failure)
        if: failure()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{}');
            const failing = (result.failures || []).map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const name = ctx.name || 'Unnamed check';
              return `❌ ${name}: ${status}`;
            });

            const body = [
              '❌ **Required checks failed!**',
              '',
              failing.length ? failing.join('\n') : '- Unable to identify failing required checks.',
              '',
              `Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

  auto-merge:
    name: Auto Merge
    needs: required-checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge PR
        id: merge
        run: |
          echo "Attempting to merge PR #${{ github.event.pull_request.number }}..."

          # mainブランチに切り替え
          git checkout main
          git pull origin main

          # PRブランチをマージ（--no-ffでマージコミットを作成）
          if git merge --no-ff -m "Merge pull request #${{ github.event.pull_request.number }} from ${{ github.head_ref }}" "origin/${{ github.head_ref }}"; then
            echo "merge_success=true" >> $GITHUB_OUTPUT

            # mainブランチにpush
            git push origin main

            echo "✅ PR merged successfully"
          else
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "❌ Merge failed (conflict detected)"
            exit 1
          fi

      - name: Close PR
        if: steps.merge.outputs.merge_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            })

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ **PR automatically merged!**\n\nAll required checks passed and the PR has been successfully merged into the main branch.'
            })

      - name: Comment on merge failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ **Auto-merge failed!**\n\nA merge conflict was detected. Please resolve the conflicts manually and try again.\n\nTo resolve:\n1. Pull the latest changes from main\n2. Merge main into your feature branch\n3. Resolve any conflicts\n4. Push the changes'
            })
