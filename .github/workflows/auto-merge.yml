name: Auto Merge PR

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  required-checks:
    name: Required Checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Wait for required checks
        id: wait-required
        uses: actions/github-script@v7
        with:
          script: |
            const coreLib = require('@actions/core');
            const { owner, repo } = context.repo;
            const pullNumber = context.payload.pull_request.number;
            const maxAttempts = 40;
            const delayMs = 15000;

            const query = `
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $number) {
                    commits(last: 1) {
                      nodes {
                        commit {
                          statusCheckRollup {
                            contexts(first: 100) {
                              nodes {
                                __typename
                                isRequired
                                ... on CheckRun {
                                  name
                                  status
                                  conclusion
                                  detailsUrl
                                }
                                ... on StatusContext {
                                  context
                                  state
                                  targetUrl
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            function normalize(node) {
              if (!node?.isRequired) {
                return null;
              }

              if (node.__typename === 'CheckRun') {
                return {
                  type: 'CheckRun',
                  name: node.name,
                  status: node.status || 'UNKNOWN',
                  conclusion: node.conclusion || null,
                  detailsUrl: node.detailsUrl || null
                };
              }

              return {
                type: 'StatusContext',
                name: node.context,
                status: node.state || 'UNKNOWN',
                conclusion: node.state || 'UNKNOWN',
                detailsUrl: node.targetUrl || null
              };
            }

            async function fetchRequired() {
              const data = await github.graphql(query, { owner, repo, number: pullNumber });
              const nodes = data.repository?.pullRequest?.commits?.nodes ?? [];
              const latest = nodes[nodes.length - 1];
              const contexts = latest?.commit?.statusCheckRollup?.contexts?.nodes ?? [];
              return contexts.map(normalize).filter(Boolean);
            }

            const summarize = (contexts) => contexts.map((ctx) => ({
              type: ctx.type,
              name: ctx.name,
              status: ctx.status,
              conclusion: ctx.conclusion,
              detailsUrl: ctx.detailsUrl
            }));

            function isPending(ctx) {
              if (ctx.type === 'CheckRun') {
                return (ctx.status || '').toUpperCase() !== 'COMPLETED';
              }
              const state = (ctx.status || '').toUpperCase();
              return state === 'PENDING' || state === 'EXPECTED';
            }

            function isFailure(ctx) {
              if (ctx.type === 'CheckRun') {
                if ((ctx.status || '').toUpperCase() !== 'COMPLETED') {
                  return false;
                }

                const conclusion = (ctx.conclusion || '').toUpperCase();
                return conclusion && !['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(conclusion);
              }

              const state = (ctx.status || '').toUpperCase();
              return state === 'ERROR' || state === 'FAILURE';
            }

            let attempt = 0;
            let latestContexts = [];

            while (attempt < maxAttempts) {
              latestContexts = await fetchRequired();

              if (latestContexts.length === 0) {
                coreLib.info('No required checks configured; proceeding.');
                const result = { state: 'no_required_checks', contexts: [] };
                coreLib.setOutput('result', JSON.stringify(result));
                return result;
              }

              const failures = latestContexts.filter(isFailure);
              if (failures.length > 0) {
                const result = {
                  state: 'failed',
                  contexts: summarize(latestContexts),
                  failures: summarize(failures)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                coreLib.setFailed('Required checks failed.');
                return result;
              }

              const pending = latestContexts.filter(isPending);
              if (pending.length === 0) {
                const result = {
                  state: 'passed',
                  contexts: summarize(latestContexts)
                };
                coreLib.setOutput('result', JSON.stringify(result));
                return result;
              }

              attempt += 1;
              coreLib.info(`Waiting for required checks to complete (attempt ${attempt}/${maxAttempts})...`);
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            }

            const result = {
              state: 'timeout',
              contexts: summarize(latestContexts)
            };
            coreLib.setOutput('result', JSON.stringify(result));
            coreLib.setFailed('Timed out waiting for required checks.');
            return result;

      - name: Comment on PR (Success)
        if: success()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{"contexts":[]}');
            const lines = result.contexts?.map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const icon = ['SUCCESS', 'NEUTRAL', 'SKIPPED'].includes(status) ? '✅' : 'ℹ️';
              const name = ctx.name || 'Unnamed check';
              return `${icon} ${name}: ${status}`;
            }) || [];

            const body = [
              '✅ **All required checks passed!**',
              '',
              lines.length ? lines.join('\n') : '- No required checks configured on the target branch.',
              '',
              'The PR is ready to be merged automatically.'
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Comment on PR (Failure)
        if: failure()
        uses: actions/github-script@v7
        env:
          RESULT_JSON: ${{ steps.wait-required.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.RESULT_JSON || '{}');
            const failing = (result.failures || []).map((ctx) => {
              const status = (ctx.conclusion || ctx.status || 'UNKNOWN').toUpperCase();
              const name = ctx.name || 'Unnamed check';
              return `❌ ${name}: ${status}`;
            });

            const body = [
              '❌ **Required checks failed!**',
              '',
              failing.length ? failing.join('\n') : '- Unable to identify failing required checks.',
              '',
              `Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

  auto-merge:
    name: Auto Merge
    needs: required-checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge PR
        id: merge
        run: |
          echo "Attempting to merge PR #${{ github.event.pull_request.number }}..."

          # mainブランチに切り替え
          git checkout main
          git pull origin main

          # PRブランチをマージ（--no-ffでマージコミットを作成）
          if git merge --no-ff -m "Merge pull request #${{ github.event.pull_request.number }} from ${{ github.head_ref }}" "origin/${{ github.head_ref }}"; then
            echo "merge_success=true" >> $GITHUB_OUTPUT

            # mainブランチにpush
            git push origin main

            echo "✅ PR merged successfully"
          else
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "❌ Merge failed (conflict detected)"
            exit 1
          fi

      - name: Close PR
        if: steps.merge.outputs.merge_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            })

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ **PR automatically merged!**\n\nAll required checks passed and the PR has been successfully merged into the main branch.'
            })

      - name: Comment on merge failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ **Auto-merge failed!**\n\nA merge conflict was detected. Please resolve the conflicts manually and try again.\n\nTo resolve:\n1. Pull the latest changes from main\n2. Merge main into your feature branch\n3. Resolve any conflicts\n4. Push the changes'
            })
