# リサーチログ: Unity AIエージェントウィンドウ

**機能ID**: `SPEC-85bab2a1`
**最終更新**: 2025-10-30

## サマリー
- 既存のターミナル仕様はアーカイブ済み。AIエージェント専用の体験を優先する。
- Unity側はUI ToolkitベースのチャットUI、新規セッション管理クラスが必要。
- Node側はMCPツール群を拡張し、Codex/Claude/カスタムツールへプロキシする設計が必要。
- 以下の論点は追加調査または意思決定が必要。

## 未解決の論点とアクション
| ID | テーマ | 状態 | 次のアクション |
|----|--------|------|----------------|
| RQ-1 | カスタムAIツールの登録/認証管理 | 完了 | Codex/Claudeはコード固定。カスタムツールのみ `.unity/config.json` の `aiAgents` で宣言する方針を採用 |
| RQ-2 | セッション情報の保持方針 (ワンショット vs 短期永続) | 完了 | Unity再起動を跨いだ復元は不要。メモリ保持を基本とし、任意で短期キャッシュを有効化できる設計へ |
| RQ-3 | エージェント応答のストリーミング可否とUI更新戦略 | 調査中 | Node SDK / Unity UI Toolkit のサンプルを確認し、逐次描画の性能影響を測定する計画を立てる |
| RQ-4 | 実行ログの最大件数と保管ポリシー | 調査中 | チャットビューのパフォーマンス実測計画を作成し、ログサマリ圧縮の要否を検討する |
| RQ-5 | 既存ターミナルハンドラ資産の再利用範囲 | 調査済み | `mcp-server/src/handlers/terminal/*.js` でシェル実行ロジックが既に存在。AIエージェントのシェル操作はこれをラップして再利用する方針 |

## 調査ノート

### RQ-1: カスタムAIツール設定
- Codex/Claude Code はサーバー内で固定定義し、ユーザー設定は不要とする。
- `mcp-server/src/core/config.js` では `.unity/config.json` をマージする仕組みが既にあるため、カスタムツールのみ `aiAgents` 配列に記述する。
- シンプルなスキーマ案:
  ```json
  {
    "aiAgents": [
      {
        "id": "custom-doc-bot",
        "provider": "http",
        "endpoint": "https://example.com/agents/doc-bot",
        "capabilities": ["code"],
        "auth": { "type": "bearer", "tokenEnv": "DOC_BOT_TOKEN" },
        "metadata": { "label": "社内ドキュメント検索" }
      }
    ]
  }
  ```
- `aiAgents` が存在しない場合でも問題なく起動し、Codex/Claude の2件は常に利用可能とする。
- 将来的にUnity UIから登録させる場合は、このJSONを更新するスクリプト/ツールを別途検討する。

### RQ-2: セッション保持方針
- 期待動作: Unityセッション中は複数ウィンドウを跨いで会話履歴を保持し、Unity終了時に破棄する。再起動後の継続はスコープ外。
- 選定案: Node/Unity双方でインメモリ保持をデフォルトとし、`aiSessions.cache.enabled` 設定が有効な場合のみ better-sqlite3 に最新N件 (標準100) をスナップショット保存。
- 比較: 
  | 方式 | 利点 | 欠点 |
  | --- | --- | --- |
  | インメモリのみ | 実装が単純、パフォーマンス高 | Unity終了で履歴消失、ログ共有不可 |
  | 短期キャッシュ (オプション) | ログ確認や復旧に利用可、容量制御しやすい | データ移行コスト、SQLiteアクセス増 |
- 決定: デフォルトはインメモリ、オプションでキャッシュを有効化できるように `aiSessions.cache` 設定を設ける。

### RQ-3: ストリーミング応答
- Node側では @modelcontextprotocol/sdk がストリーミング対応 (`tool.handler.onChunk`) を提供していることを確認。Unity側で逐次反映する場合、UI Toolkit の `ListView` + `ScrollView` の最適化が必要。
- 仮リスク: 大量トークン出力でEditorがフリーズする可能性。`Dispatcher` 経由でチャンクをバッチ処理する案を検討。
- シンプル案: Node側でチャンクを一定長にまとめて送信し、Unityでは1フレームあたりのUI更新数を制限する。
- 旧ターミナルのTerminalReadはポーリング前提のため、本機能では push 型のイベント (Unity側 -> UI) を新設予定。

### RQ-5: ターミナルハンドラの再利用
- 既存ファイル: `mcp-server/src/handlers/terminal/TerminalOpenToolHandler.js` ほか3件。
- これらはシェル起動や標準入出力管理を既に実装しているため、AIエージェントの「シェル実行提案」は新規ツールから既存ハンドラを呼び出し、共通ログ整形レイヤーを挟む形にする。
- Unity側は旧ターミナルUIを利用しないが、プロセス管理ロジックの重複を避けられる。

### RQ-4: ログ保持/クリッピング
- チャットUIの表示上限を 1000 メッセージまたは 200KB のどちらか小さい方に制限。閾値を超えた場合は古いメッセージを「要約ノード」に折りたたむ。
- Node側では構造化ログ (sessionId, actionId, lines[]) を生成し、`aiSessions.cache` が有効時のみSQLiteへ追記。エクスポート操作時はJSONLとして保存。
- Unityウィンドウに「ログを保存」「表示をクリア」ボタンを追加し、ユーザーが明示的に管理できるようにする。
- パフォーマンス計測: 10k行/500KBのテキストを入力として、スクロール体感遅延とGC発生状況を測定。遅延 > 200ms なら1フレームあたりの描画件数を制限するバッチ処理を実装。

## 参考コード
- `mcp-server/src/handlers/terminal/*.js` — シェル実行ロジックの再利用候補
- `UnityMCPServer/Packages/unity-mcp-server/Editor/Terminal/` — 旧ターミナルWindow実装。UI要件は異なるため直接流用しないが、Processラッパーの使い方を参考にする
- `CLAUDE.md` — 既存のエージェント向けインストラクション。新UI追加時に更新が必要

## 次のステップ (Phase 0 継続)
- [ ] RQ-3: ストリーミング実装プロトタイプの検証 — Nodeハンドラで疑似チャンクを返すテストを作成
- [ ] RQ-4: ログ保持ポリシー案のベンチマーク計画 (10k行テスト) を策定し、必要な計測スクリプトを定義
- [ ] research.md を更新し、未解決項目が解決したら `status=完了` に変更する
