# リサーチログ: Unity AIエージェントウィンドウ

**機能ID**: `SPEC-85bab2a1`
**最終更新**: 2025-10-30

## サマリー
- 既存のターミナル仕様はアーカイブ済み。AIエージェント専用の体験を優先する。
- Unity側はUI ToolkitベースのチャットUI、新規セッション管理クラスが必要。
- Node側はMCPツール群を拡張し、Codex/Claude/カスタムツールへプロキシする設計が必要。
- 以下の論点は追加調査または意思決定が必要。

## 未解決の論点とアクション
| ID | テーマ | 状態 | 次のアクション |
|----|--------|------|----------------|
| RQ-1 | カスタムAIツールの登録/認証管理 | 未着手 | 既存設定ファイル (`mcp-server/.unity/config.json` など) の拡張可否を調査し、候補フォーマットを比較する |
| RQ-2 | セッション情報の保持方針 (ワンショット vs 短期永続) | 未着手 | Unity/Node双方でのライフサイクル要件を整理し、最小限の永続化要否を判断する |
| RQ-3 | エージェント応答のストリーミング可否とUI更新戦略 | 下調べ中 | Node SDK / Unity UI Toolkit のサンプルを確認し、逐次描画の性能影響を測定する計画を立てる |
| RQ-4 | 実行ログの最大件数と保管ポリシー | 未着手 | チャットビューのパフォーマンス実測計画を作成し、ログサマリ圧縮の要否を検討する |
| RQ-5 | 既存ターミナルハンドラ資産の再利用範囲 | 調査済み | `mcp-server/src/handlers/terminal/*.js` でシェル実行ロジックが既に存在。AIエージェントのシェル操作はこれをラップして再利用する方針 |

## 調査ノート

### RQ-3: ストリーミング応答
- Node側では @modelcontextprotocol/sdk がストリーミング対応 (`tool.handler.onChunk`) を提供していることを確認。Unity側で逐次反映する場合、UI Toolkit の `ListView` + `ScrollView` の最適化が必要。
- 仮リスク: 大量トークン出力でEditorがフリーズする可能性。`Dispatcher` 経由でチャンクをバッチ処理する案を検討。

### RQ-5: ターミナルハンドラの再利用
- 既存ファイル: `mcp-server/src/handlers/terminal/TerminalOpenToolHandler.js` ほか3件。
- これらはシェル起動や標準入出力管理を既に実装しているため、AIエージェントの「シェル実行提案」は新規ツールから既存ハンドラを呼び出し、共通ログ整形レイヤーを挟む形にする。
- Unity側は旧ターミナルUIを利用しないが、プロセス管理ロジックの重複を避けられる。

## 参考コード
- `mcp-server/src/handlers/terminal/*.js` — シェル実行ロジックの再利用候補
- `UnityMCPServer/Packages/unity-mcp-server/Editor/Terminal/` — 旧ターミナルWindow実装。UI要件は異なるため直接流用しないが、Processラッパーの使い方を参考にする
- `CLAUDE.md` — 既存のエージェント向けインストラクション。新UI追加時に更新が必要

## 次のステップ (Phase 0 継続)
- [ ] RQ-1: カスタムAIツール設定形式の候補調査 (JSON設定, UI登録, 外部CLI) — 2025-10-31 までにドラフト化
- [ ] RQ-2: セッション存続条件のユーザービヘイビア調査 (複数Unity再起動ケース) — 2025-11-01 までに結論
- [ ] RQ-3: ストリーミング実装プロトタイプの検証 — Nodeハンドラで疑似チャンクを返すテストを作成
- [ ] RQ-4: ログ保持ポリシー案 (メッセージ数・クリッピング戦略) を提示
- [ ] research.md を更新し、未解決項目が解決したら `status=完了` に変更する

