# 機能仕様書: C# LSP統合機能

**機能ID**: `SPEC-e757a01f`
**作成日**: 2025-10-17
**ステータス**: 下書き
**入力**: ユーザー説明: "C# LSP統合機能"

## 実行フロー (main)
```
1. 入力からユーザー説明を解析
   → 完了: "C# LSP統合機能"
2. 説明から主要概念を抽出
   → アクター: Unity開発者、LLMユーザー
   → アクション: シンボル検索、参照検索、構造化編集、リネーム、インデックス管理
   → データ: C#シンボル、ソースコード、編集操作
   → 制約: Roslyn LSP、Unity非依存、構造化操作のみ
3. 不明確な側面: なし（既存実装のSpec化）
4. ユーザーシナリオ＆テストセクションを記入
   → 6つの主要ユーザーストーリー定義済み
5. 機能要件を生成
   → 25個の機能要件をテスト可能な形式で定義
6. 主要エンティティを識別
   → シンボル、編集操作、インデックス
7. レビューチェックリストを実行
   → 技術詳細は参考実装セクションに分離
   → 要件はテスト可能
8. 戻り値: SUCCESS (計画準備完了)
```

---

## ⚡ クイックガイドライン
- ✅ ユーザーが「何を」必要とし「なぜ」必要なのかに焦点を当てる
- ❌ 「どのように」実装するかを避ける (技術スタック、API、コード構造なし)
- 👥 ビジネス関係者向けに記述 (開発者向けではない)

---

## 機能概要

自己完結型のC# Language Server (LSP) を使用した、シンボル検索・参照検索・構造化編集・リネーム・インデックス管理機能。Unity通信に依存せず、ローカルでC#コードを安全に操作する。

### ビジネス価値

- **安全なコード編集**: 構造化操作により、行ベースの危険な編集を排除
- **効率的な検索**: シンボルインデックスにより、大規模コードベースでも高速検索
- **Unity非依存**: LSPはスタンドアロンで動作し、Unity Editor停止中でもコード編集可能

---

## ユーザーシナリオ＆テスト

### 主要ユーザーストーリー

#### US-1: シンボル検索

**AS** Unity開発者
**I WANT** クラス名/メソッド名/フィールド名でシンボルを検索したい
**SO THAT** 大規模プロジェクトでも目的のコードを素早く特定できる

**受け入れ基準**:
- 名前でシンボルを検索できる（部分一致/完全一致）
- シンボル種別（class/method/field/property）で絞り込める
- 検索スコープ（Assets/Packages/All）を指定できる
- 検索結果にファイルパス、行番号、コンテナ情報が含まれる

#### US-2: 参照検索

**AS** Unity開発者
**I WANT** シンボルの使用箇所をすべて検索したい
**SO THAT** リファクタリング影響範囲を把握できる

**受け入れ基準**:
- シンボル名を指定して参照箇所を検索できる
- 参照箇所にファイルパス、行番号、コード断片が含まれる
- スニペットコンテキスト行数を指定できる
- ページング対応でLLM最適化されている

#### US-3: 構造化編集（挿入/置換）

**AS** Unity開発者
**I WANT** メソッド本体やクラスメンバーを安全に編集したい
**SO THAT** 手動の行番号指定による編集ミスを防げる

**受け入れ基準**:
- シンボルを指定してメソッド本体を置換できる
- クラス内にメソッドを挿入できる（before/after指定）
- 編集前にプレビューできる（オプション）
- エラー時に詳細な診断情報が返る

#### US-4: リネーム（リファクタリング）

**AS** Unity開発者
**I WANT** クラス/メソッド/フィールド名を一括リネームしたい
**SO THAT** 手動での置換漏れを防げる

**受け入れ基準**:
- シンボルを指定してプロジェクト全体でリネームできる
- リネーム前にプレビューできる
- 依存ファイルすべてに変更が適用される

#### US-5: シンボル定義取得

**AS** LLMユーザー
**I WANT** ファイル内のすべてのシンボル定義を取得したい
**SO THAT** コード構造を理解できる

**受け入れ基準**:
- ファイルパスを指定してシンボル一覧を取得できる
- シンボルの種別、名前、位置、コンテナが含まれる
- ネストされたシンボル（内部クラス等）も取得できる

#### US-6: コードインデックス管理

**AS** Unity開発者
**I WANT** コードインデックスを構築・更新したい
**SO THAT** シンボル検索が高速に動作する

**受け入れ基準**:
- プロジェクト全体のインデックスを構築できる
- インデックス状態（ファイル数、カバレッジ）を確認できる
- 増分更新をサポートする

### 受け入れシナリオ

1. **前提** プロジェクトにC#ファイルが存在、**実行** クラス名検索、**結果** 該当クラスの定義場所が返る
2. **前提** メソッドが複数箇所で使用、**実行** 参照検索、**結果** すべての使用箇所リストが返る
3. **前提** メソッドが存在、**実行** メソッド本体置換、**結果** 新しい本体に置き換わる
4. **前提** クラス名が複数ファイルで使用、**実行** リネーム、**結果** すべてのファイルで名前が変更される
5. **前提** C#ファイルが存在、**実行** シンボル定義取得、**結果** ファイル内の全シンボルリストが返る
6. **前提** プロジェクトが存在、**実行** インデックス構築、**結果** インデックスが作成され、検索が高速化される

### エッジケース

- 存在しないシンボルを検索した場合、空の結果が返るか?
- 構造化編集でシンボルが見つからない場合、エラーメッセージは明確か?
- リネーム時に構文エラーが発生した場合、変更はロールバックされるか?
- 大規模プロジェクト（10000+ファイル）でインデックス構築時間は許容範囲か?
- インデックス構築中に検索を実行した場合、どのように処理されるか?

---

## 要件

### シンボル検索機能要件

- **FR-001**: システムは名前でシンボルを検索できる必要がある（部分一致/完全一致）
- **FR-002**: システムはシンボル種別（class/method/field/property）で絞り込める必要がある
- **FR-003**: システムは検索スコープ（Assets/Packages/Embedded/All）を指定できる必要がある
- **FR-004**: システムは検索結果にファイルパス、行番号、コンテナ情報を含める必要がある

### 参照検索機能要件

- **FR-005**: システムはシンボル名を指定して参照箇所を検索できる必要がある
- **FR-006**: システムは参照箇所にファイルパス、行番号、コード断片を含める必要がある
- **FR-007**: システムはスニペットコンテキスト行数を指定できる必要がある
- **FR-008**: システムは参照検索結果をページングできる必要がある

### 構造化編集機能要件

- **FR-009**: システムはシンボルを指定してメソッド本体を置換できる必要がある
- **FR-010**: システムはクラス内にメソッドを挿入できる必要がある（before/after指定）
- **FR-011**: システムは編集前にプレビューを提供できる必要がある（オプション）
- **FR-012**: システムは編集エラー時に詳細な診断情報を返す必要がある
- **FR-013**: システムは行ベース編集を禁止し、構造化操作のみ許可する必要がある

### リネーム機能要件

- **FR-014**: システムはシンボルを指定してプロジェクト全体でリネームできる必要がある
- **FR-015**: システムはリネーム前にプレビューを提供できる必要がある
- **FR-016**: システムは依存ファイルすべてに変更を適用する必要がある
- **FR-017**: システムはリネーム失敗時に変更をロールバックする必要がある

### シンボル定義取得機能要件

- **FR-018**: システムはファイルパスを指定してシンボル一覧を取得できる必要がある
- **FR-019**: システムはシンボルの種別、名前、位置、コンテナを含める必要がある
- **FR-020**: システムはネストされたシンボル（内部クラス等）も取得できる必要がある

### インデックス管理機能要件

- **FR-021**: システムはプロジェクト全体のインデックスを構築できる必要がある
- **FR-022**: システムはインデックス状態（ファイル数、カバレッジ）を確認できる必要がある
- **FR-023**: システムは増分更新をサポートする必要がある
- **FR-024**: システムはインデックスをSQLiteに永続化する必要がある

### 非機能要件

#### 性能要件

- **NFR-001**: シンボル検索は1000ファイルで1秒以内に完了する必要がある
- **NFR-002**: インデックス構築は10000ファイルで2分以内に完了する必要がある

#### 信頼性要件

- **NFR-003**: 構造化編集は構文エラーを事前検出する必要がある
- **NFR-004**: リネームは原子的操作である必要がある（全成功または全失敗）

#### LLM最適化要件

- **NFR-005**: 検索結果はページング対応である必要がある（maxBytes、pageSize）
- **NFR-006**: 参照検索はスニペットコンテキストを制限できる必要がある
- **NFR-007**: エラーメッセージは要約される必要がある（≤30件、≤200文字）

### 主要エンティティ

- **シンボル**: クラス/メソッド/フィールド/プロパティ等のコード要素。名前、種別、位置、コンテナを持つ
- **編集操作**: コード変更の単位。挿入/置換/削除、対象シンボル、新しいテキストを含む
- **インデックス**: シンボル情報のSQLiteデータベース。高速検索のために永続化される

---

## スコープ外

以下の機能は本仕様のスコープ外とし、将来のバージョンで対応:

- コード補完機能
- ホバー情報表示
- 定義ジャンプ（IDEナビゲーション）
- コードフォーマット機能
- リアルタイム診断（エラーチェック）

---

## 技術制約

- 自己完結型Roslyn LSPを使用（Unity通信不要）
- インデックスは`.unity/cache/code-index`に保存
- 構造化操作のみサポート（行ベース編集禁止）
- Unityコンパイル/ドメインリロードの影響を受けない

---

## 参考実装

本仕様は既存実装を文書化したものです。参考実装:

- `mcp-server/src/handlers/script/ScriptSymbolFindToolHandler.js`: シンボル検索
- `mcp-server/src/handlers/script/ScriptRefsFindToolHandler.js`: 参照検索
- `mcp-server/src/handlers/script/ScriptEditStructuredToolHandler.js`: 構造化編集
- `mcp-server/src/handlers/script/ScriptRefactorRenameToolHandler.js`: リネーム
- `mcp-server/src/handlers/script/ScriptSymbolsGetToolHandler.js`: シンボル定義取得
- `mcp-server/src/handlers/script/BuildCodeIndexToolHandler.js`: インデックス構築
- `mcp-server/src/handlers/script/ScriptIndexStatusToolHandler.js`: インデックス状態

---

## レビュー＆受け入れチェックリスト

### コンテンツ品質
- [x] 実装詳細なし (言語、フレームワーク、API)
- [x] ユーザー価値とビジネスニーズに焦点
- [x] 非技術関係者向けに記述
- [x] すべての必須セクション完成

### 要件完全性
- [x] [要明確化]マーカーが残っていない
- [x] 要件はテスト可能で曖昧さがない
- [x] 成功基準は測定可能
- [x] スコープが明確に境界付けられている
- [x] 依存関係と前提条件が識別されている

---

## 実行ステータス

- [x] ユーザー説明を解析済み
- [x] 主要概念を抽出済み
- [x] 曖昧さをマーク済み（なし）
- [x] ユーザーシナリオを定義済み
- [x] 要件を生成済み
- [x] エンティティを識別済み
- [x] レビューチェックリスト合格

**ステータス**: ✅ 計画フェーズ準備完了
