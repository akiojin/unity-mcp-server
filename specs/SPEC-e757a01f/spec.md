# 機能仕様書: C# LSP統合機能

**機能ID**: `SPEC-e757a01f`
**作成日**: 2025-10-17
**ステータス**: 完了
**入力**: ユーザー説明: "C# LSP統合機能"

## 実行フロー (main)
```
1. 入力からユーザー説明を解析
   → 完了: "C# LSP統合機能"
2. 説明から主要概念を抽出
   → アクター: Unity開発者、LLMユーザー
   → アクション: シンボル検索、参照検索、構造化編集、軽量スニペット編集、リネーム、インデックス管理
   → データ: C#シンボル、ソースコード、編集操作
   → 制約: Roslyn LSP、Unity非依存、構造化操作のみ
3. 不明確な側面: なし（既存実装のSpec化）
4. ユーザーシナリオ＆テストセクションを記入
   → 7つの主要ユーザーストーリー定義済み
5. 機能要件を生成
   → 34個の機能要件をテスト可能な形式で定義
6. 主要エンティティを識別
   → シンボル、編集操作、インデックス
7. レビューチェックリストを実行
   → 技術詳細は参考実装セクションに分離
   → 要件はテスト可能
8. 戻り値: SUCCESS (計画準備完了)
```

---

## ⚡ クイックガイドライン
- ✅ ユーザーが「何を」必要とし「なぜ」必要なのかに焦点を当てる
- ❌ 「どのように」実装するかを避ける (技術スタック、API、コード構造なし)
- 👥 ビジネス関係者向けに記述 (開発者向けではない)

---

## 機能概要

自己完結型のC# Language Server (LSP) を使用した、シンボル検索・参照検索・構造化編集・軽量スニペット編集・リネーム・インデックス管理機能。Unity通信に依存せず、ローカルでC#コードを安全に操作する。

### ビジネス価値

- **安全なコード編集**: 構造化操作により、行ベースの危険な編集を排除
- **効率的な検索**: シンボルインデックスにより、大規模コードベースでも高速検索
- **Unity非依存**: LSPはスタンドアロンで動作し、Unity Editor停止中でもコード編集可能
- **柔軟な編集粒度**: 大規模な構造化編集と1-2行の軽量編集を使い分けることで、LLMエージェントの効率を最大化

---

## ユーザーシナリオ＆テスト

### 主要ユーザーストーリー

#### US-1: シンボル検索

**AS** Unity開発者
**I WANT** クラス名/メソッド名/フィールド名でシンボルを検索したい
**SO THAT** 大規模プロジェクトでも目的のコードを素早く特定できる

**受け入れ基準**:
- 名前でシンボルを検索できる（部分一致/完全一致）
- シンボル種別（class/method/field/property）で絞り込める
- 検索スコープ（Assets/Packages/All）を指定できる
- 検索結果にファイルパス、行番号、コンテナ情報が含まれる

#### US-2: 参照検索

**AS** Unity開発者
**I WANT** シンボルの使用箇所をすべて検索したい
**SO THAT** リファクタリング影響範囲を把握できる

**受け入れ基準**:
- シンボル名を指定して参照箇所を検索できる
- 参照箇所にファイルパス、行番号、コード断片が含まれる
- スニペットコンテキスト行数を指定できる
- ページング対応でLLM最適化されている

#### US-3: 構造化編集（挿入/置換）

**AS** Unity開発者
**I WANT** メソッド本体やクラスメンバーを安全に編集したい
**SO THAT** 手動の行番号指定による編集ミスを防げる

**受け入れ基準**:
- シンボルを指定してメソッド本体を置換できる
- クラス内にメソッドを挿入できる（before/after指定）
- 編集前にプレビューできる（オプション）
- エラー時に詳細な診断情報が返る

#### US-4: リネーム（リファクタリング）

**AS** Unity開発者
**I WANT** クラス/メソッド/フィールド名を一括リネームしたい
**SO THAT** 手動での置換漏れを防げる

**受け入れ基準**:
- シンボルを指定してプロジェクト全体でリネームできる
- リネーム前にプレビューできる
- 依存ファイルすべてに変更が適用される

#### US-5: シンボル定義取得

**AS** LLMユーザー
**I WANT** ファイル内のすべてのシンボル定義を取得したい
**SO THAT** コード構造を理解できる

**受け入れ基準**:
- ファイルパスを指定してシンボル一覧を取得できる
- シンボルの種別、名前、位置、コンテナが含まれる
- ネストされたシンボル（内部クラス等）も取得できる

#### US-6: コードインデックス管理

**AS** Unity開発者
**I WANT** コードインデックスを構築・更新したい
**SO THAT** シンボル検索が高速に動作する

**受け入れ基準**:
- プロジェクト全体のインデックスを構築できる
- インデックス状態（ファイル数、カバレッジ）を確認できる
- 増分更新をサポートする

#### US-7: 軽量スニペット編集

**AS** LLMエージェント
**I WANT** 1-2行規模のコード断片を安全に編集したい
**SO THAT** メソッド全体を置換せずに局所的な変更を高速に適用できる

**受け入れ基準**:
- 同一ファイル内で最大10箇所の編集を1回の呼び出しで処理できる
- アンカー文字列（前後のコードスニペット）を指定して編集対象を特定できる
- 編集内容は80文字以内に制限され、超過する場合は拒否される
- 括弧・波括弧の整合性チェックが自動実行され、エラー時はロールバックされる
- 各編集の適用結果（applied/skipped/error）と理由が返される
- ガード削除（nullチェック等）、条件式の最小変更、ログ挿入が主な用途

**主要サブシナリオ**:

**US-7.1: ガード削除**
- 例外的なnullチェック（`if (foo == null) { return; }`）を安全に削除
- 削除対象が見つからない場合は適用せず、警告を返す
- 編集後の空行や余分なセミコロンを自動整理

**US-7.2: 条件式の最小変更**
- 比較演算子や呼び出し名など部分一致で最大5箇所まで置換
- 周辺コンテキスト（前後2行）を指定して誤適用を防ぐ

**US-7.3: ログ挿入**
- return文など特定キーワードをアンカーに直前へ1行挿入
- 既存ログとの重複を検出し、重複時は挿入しない

### 受け入れシナリオ

1. **前提** プロジェクトにC#ファイルが存在、**実行** クラス名検索、**結果** 該当クラスの定義場所が返る
2. **前提** メソッドが複数箇所で使用、**実行** 参照検索、**結果** すべての使用箇所リストが返る
3. **前提** メソッドが存在、**実行** メソッド本体置換、**結果** 新しい本体に置き換わる
4. **前提** クラス名が複数ファイルで使用、**実行** リネーム、**結果** すべてのファイルで名前が変更される
5. **前提** C#ファイルが存在、**実行** シンボル定義取得、**結果** ファイル内の全シンボルリストが返る
6. **前提** プロジェクトが存在、**実行** インデックス構築、**結果** インデックスが作成され、検索が高速化される
7. **前提** メソッド内にnullチェックガードが存在、**実行** アンカー指定でガード削除、**結果** ガードが削除され括弧整合性が保たれる
8. **前提** 条件式に誤った演算子が存在、**実行** 周辺コンテキスト指定で置換、**結果** 正しい演算子に置き換わる
9. **前提** メソッド内に複数のreturn文が存在、**実行** ログ挿入をreturn前に適用、**結果** すべてのreturn直前にログが挿入される

### エッジケース

- 存在しないシンボルを検索した場合、空の結果が返るか?
- 構造化編集でシンボルが見つからない場合、エラーメッセージは明確か?
- リネーム時に構文エラーが発生した場合、変更はロールバックされるか?
- 大規模プロジェクト（10000+ファイル）でインデックス構築時間は許容範囲か?
- インデックス構築中に検索を実行した場合、どのように処理されるか?
- 軽量スニペット編集でアンカーが一意に決定できない場合、候補一覧が返されるか?
- 編集対象がコメントアウトされている場合、無視して警告が返されるか?
- 編集後にコードフォーマッタが破綻する恐れがある場合、適用が拒否されるか?
- 80文字制限を超える編集指示が与えられた場合、拒否理由と代替案が提示されるか?
- ファイルがロックされている場合、失敗理由が明示されるか?

---

## 要件

### シンボル検索機能要件

- **FR-001**: システムは名前でシンボルを検索できる必要がある（部分一致/完全一致）
- **FR-002**: システムはシンボル種別（class/method/field/property）で絞り込める必要がある
- **FR-003**: システムは検索スコープ（Assets/Packages/Embedded/All）を指定できる必要がある
- **FR-004**: システムは検索結果にファイルパス、行番号、コンテナ情報を含める必要がある

### 参照検索機能要件

- **FR-005**: システムはシンボル名を指定して参照箇所を検索できる必要がある
- **FR-006**: システムは参照箇所にファイルパス、行番号、コード断片を含める必要がある
- **FR-007**: システムはスニペットコンテキスト行数を指定できる必要がある
- **FR-008**: システムは参照検索結果をページングできる必要がある

### 構造化編集機能要件

- **FR-009**: システムはシンボルを指定してメソッド本体を置換できる必要がある
- **FR-010**: システムはクラス内にメソッドを挿入できる必要がある（before/after指定）
- **FR-011**: システムは編集前にプレビューを提供できる必要がある（オプション）
- **FR-012**: システムは編集エラー時に詳細な診断情報を返す必要がある
- **FR-013**: システムは行ベース編集を禁止し、構造化操作のみ許可する必要がある

### リネーム機能要件

- **FR-014**: システムはシンボルを指定してプロジェクト全体でリネームできる必要がある
- **FR-015**: システムはリネーム前にプレビューを提供できる必要がある
- **FR-016**: システムは依存ファイルすべてに変更を適用する必要がある
- **FR-017**: システムはリネーム失敗時に変更をロールバックする必要がある

### シンボル定義取得機能要件

- **FR-018**: システムはファイルパスを指定してシンボル一覧を取得できる必要がある
- **FR-019**: システムはシンボルの種別、名前、位置、コンテナを含める必要がある
- **FR-020**: システムはネストされたシンボル（内部クラス等）も取得できる必要がある

### インデックス管理機能要件

- **FR-021**: システムはプロジェクト全体のインデックスを構築できる必要がある
- **FR-022**: システムはインデックス状態（ファイル数、カバレッジ）を確認できる必要がある
- **FR-023**: システムは増分更新をサポートする必要がある
- **FR-024**: システムはインデックスをSQLiteに永続化する必要がある

### 軽量スニペット編集機能要件

- **FR-025**: システムは1回の呼び出しで最大10箇所の局所編集を処理できる必要がある
- **FR-026**: システムは各編集指示に操作タイプ（削除/置換/挿入）、アンカー情報、編集内容を必須として受け取る必要がある
- **FR-027**: システムはアンカー検証を行い、対象が一意に決定できない場合は候補一覧を返す必要がある
- **FR-028**: システムはアンカー一致後の差分が80文字以内であることを検証し、超過する場合は拒否する必要がある
- **FR-029**: システムは編集結果適用前に括弧・波括弧の整合性をチェックし、不整合時は全体をロールバックする必要がある
- **FR-030**: システムは各編集について status（applied/skipped/error）と reason、編集前後のスニペットを返す必要がある
- **FR-031**: システムはプレビューモード時に副作用を発生させず、候補結果とフォーマット変更を提示する必要がある
- **FR-032**: システムは Assets/ または Packages/ 外のファイルを拒否する必要がある
- **FR-033**: システムは編集後に空になったブロック（空のif文等）を検出し、警告を返す必要がある
- **FR-034**: システムは編集結果のハッシュを返して script_edit_structured との併用時の重複適用を防ぐ必要がある

### 非機能要件

#### 性能要件

- **NFR-001**: シンボル検索は1000ファイルで1秒以内に完了する必要がある
- **NFR-002**: インデックス構築は10000ファイルで2分以内に完了する必要がある

#### 信頼性要件

- **NFR-003**: 構造化編集は構文エラーを事前検出する必要がある
- **NFR-004**: リネームは原子的操作である必要がある（全成功または全失敗）

#### LLM最適化要件

- **NFR-005**: 検索結果はページング対応である必要がある（maxBytes、pageSize）
- **NFR-006**: 参照検索はスニペットコンテキストを制限できる必要がある
- **NFR-007**: エラーメッセージは要約される必要がある（≤30件、≤200文字）

#### 軽量スニペット編集要件

- **NFR-008**: 最大10箇所編集でレスポンス時間は2秒以内である必要がある（LSP常駐時）
- **NFR-009**: エラーメッセージは200文字以内、日本語で返却される必要がある
- **NFR-010**: 成功応答のテキストフィールドは1000文字以内に抑制される必要がある
- **NFR-011**: 競合発生時は編集箇所を自動スキップし、他の編集は継続する必要がある（ベストエフォート）
- **NFR-012**: LSP未起動時は自動起動を試み、失敗時に詳細なトラブルシュート情報を返す必要がある

### 主要エンティティ

- **シンボル**: クラス/メソッド/フィールド/プロパティ等のコード要素。名前、種別、位置、コンテナを持つ
- **編集操作**: コード変更の単位。挿入/置換/削除、対象シンボル、新しいテキストを含む
- **スニペット編集操作**: 軽量な局所編集の単位。操作タイプ（削除/置換/挿入）、アンカー情報（前後のコードスニペット）、編集内容（80文字以内）、適用結果（status/reason）を含む
- **インデックス**: シンボル情報のSQLiteデータベース。高速検索のために永続化される

---

## スコープ外

以下の機能は本仕様のスコープ外とし、将来のバージョンで対応:

- コード補完機能
- ホバー情報表示
- 定義ジャンプ（IDEナビゲーション）
- コードフォーマット機能
- リアルタイム診断（エラーチェック）
- 大規模リファクタリング（複数ファイル横断での意味解析）
- テンプレート生成

---

## 技術制約

- 自己完結型Roslyn LSPを使用（Unity通信不要）
- インデックスは`.unity/cache/code-index`に保存
- 構造化操作とアンカーベース軽量編集をサポート（純粋な行ベース編集禁止）
- Unityコンパイル/ドメインリロードの影響を受けない
- 軽量スニペット編集は80文字制限、最大10箇所/リクエスト

---

## 参考実装

本仕様は既存実装を文書化したものです。参考実装:

- `mcp-server/src/handlers/script/ScriptSymbolFindToolHandler.js`: シンボル検索
- `mcp-server/src/handlers/script/ScriptRefsFindToolHandler.js`: 参照検索
- `mcp-server/src/handlers/script/ScriptEditStructuredToolHandler.js`: 構造化編集
- `mcp-server/src/handlers/script/ScriptEditSnippetToolHandler.js`: 軽量スニペット編集（計画中）
- `mcp-server/src/handlers/script/ScriptRefactorRenameToolHandler.js`: リネーム
- `mcp-server/src/handlers/script/ScriptSymbolsGetToolHandler.js`: シンボル定義取得
- `mcp-server/src/handlers/script/BuildCodeIndexToolHandler.js`: インデックス構築
- `mcp-server/src/handlers/script/ScriptIndexStatusToolHandler.js`: インデックス状態

---

## レビュー＆受け入れチェックリスト

### コンテンツ品質
- [x] 実装詳細なし (言語、フレームワーク、API)
- [x] ユーザー価値とビジネスニーズに焦点
- [x] 非技術関係者向けに記述
- [x] すべての必須セクション完成

### 要件完全性
- [x] [要明確化]マーカーが残っていない
- [x] 要件はテスト可能で曖昧さがない
- [x] 成功基準は測定可能
- [x] スコープが明確に境界付けられている
- [x] 依存関係と前提条件が識別されている

---

## 実行ステータス

- [x] ユーザー説明を解析済み
- [x] 主要概念を抽出済み
- [x] 曖昧さをマーク済み（なし）
- [x] ユーザーシナリオを定義済み
- [x] 要件を生成済み
- [x] エンティティを識別済み
- [x] レビューチェックリスト合格

**ステータス**: 完了
