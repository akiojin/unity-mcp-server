# Phase 0: リサーチ - コードインデックスビルドのバックグラウンド実行

**機能ID**: SPEC-yt3ikddd | **日付**: 2025-10-29

## リサーチ対象

### 1. Node.jsバックグラウンドジョブパターン

**調査内容**: Promise非同期実行パターン、EventEmitter vs オブジェクト参照での進捗共有

**決定**: オブジェクト参照による進捗共有

**理由**:
- Promise.allは既に使用中（Workerプールパターン）
- 進捗情報はジョブオブジェクトに直接書き込み、statusツールが読み取る
- EventEmitterは不要（追加の複雑さ、メモリオーバーヘッド）
- オブジェクト参照はシンプルで十分（単一プロセス内）

**検討した代替案**:
- **EventEmitter**: 進捗イベント発火パターン
  - 却下理由: オーバーエンジニアリング、リスナー管理が必要
- **Worker Threads**: 真の並列実行
  - 却下理由: I/Oバウンド処理（LSP RPC待機）のため不要

**参考**:
- Node.js公式: Promise-based async patterns
- 既存実装: `CodeIndexBuildToolHandler.js` (line 91-116)

---

### 2. メモリ内ジョブ管理 vs 永続化

**調査内容**: シンプルさ vs 復元可能性のトレードオフ

**決定**: メモリ内Map（永続化なし）

**理由**:
- ビルドは数十秒〜数分で完了（短期ジョブ）
- MCPサーバーの再起動は稀（通常は長時間稼働）
- SQLite永続化は複雑さ増加（スキーマ定義、マイグレーション）
- メモリ内Mapは外部依存なし、シンプル

**検討した代替案**:
- **SQLite永続化**: ジョブ情報をcode-index.dbに保存
  - 却下理由: 短期ジョブには不要、複雑さ増加
- **ファイルベース**: JSON/YAMLでジョブ情報保存
  - 却下理由: ファイルI/O不要、メモリで十分

**トレードオフ**:
- メモリ内: シンプル、高速 / サーバー再起動で消失
- 永続化: 復元可能 / 複雑、スキーマ管理必要

**メモリリーク防止策**:
- 完了ジョブは5分後に自動削除（`setTimeout`）
- ジョブID数上限設定不要（短期ジョブのため）

---

### 3. IndexWatcherとの統合

**調査内容**: 手動ビルドと自動ビルドの競合回避パターン

**決定**: JobManagerでの一元管理 + running フラグ保持

**理由**:
- IndexWatcherは既に`running`フラグで多重実行防止
- JobManagerにジョブを登録し、Watcherは実行中ジョブをチェック
- 手動ビルドが実行中なら自動ビルドをスキップ
- ジョブIDで識別: `build-xxx`（手動）、`watcher-xxx`（自動）

**検討した代替案**:
- **Watcherを停止**: 手動ビルド中はWatcher完全停止
  - 却下理由: 停止/再開の複雑さ、タイミング問題
- **キュー**: 複数ジョブをキューイング
  - 却下理由: 要件外（同時1ジョブのみ）、複雑さ増加

**実装アプローチ**:
```javascript
// IndexWatcher.tick()
if (this.running) return;

// 手動ジョブ実行中ならスキップ
const manualJobRunning = Array.from(jobManager.jobs.values())
  .some(j => j.status === 'running' && !j.id.startsWith('watcher-'));
if (manualJobRunning) return;

this.running = true;
const jobId = `watcher-${Date.now()}`;
// ジョブ実行...
```

---

### 4. 既存ハンドラの拡張パターン

**調査内容**: BaseToolHandlerの変更なしでの拡張、下位互換性維持

**決定**: 既存ハンドラを最小限変更、下位互換性完全維持

**理由**:
- BaseToolHandler変更不要（execute()内で完結）
- script_index_statusは`index.buildJob`フィールドを追加（オプショナル）
- 既存クライアントは`buildJob`を無視可能（下位互換）

**エラーハンドリング戦略**:
- **LSP起動失敗**: ジョブを`failed`にマーク、詳細エラー保存
- **ファイルアクセスエラー**: スキップして続行（ベストエフォート）
- **ジョブ中断**: 未サポート（将来的に`code_index_cancel`追加可能）

**検討した代替案**:
- **新ハンドラ作成**: `code_index_build_async` 新規ツール
  - 却下理由: ツール増加、既存ツールの置き換え必要
- **BaseToolHandler拡張**: async対応の基底クラス変更
  - 却下理由: 既存ハンドラへの影響大、不要な複雑さ

**下位互換性保証**:
- script_index_statusの既存フィールドはすべて保持
- buildJobフィールドは存在しなくてもエラーにならない
- 既存のcode_index_build呼び出しは引き続き動作（レスポンス形式変更のみ）

---

## 最終決定事項まとめ

| 項目 | 決定 | 理由 |
|------|------|------|
| ジョブ管理 | メモリ内Map | シンプル、短期ジョブに十分 |
| 進捗共有 | オブジェクト参照 | EventEmitter不要、シンプル |
| 並行制御 | 1ビルドジョブのみ | 要件、リソース競合防止 |
| 自動クリーンアップ | 完了5分後 | メモリリーク防止 |
| IndexWatcher統合 | ジョブマネージャで一元管理 | 競合回避、既存フラグ活用 |
| ハンドラ拡張 | 既存ハンドラ最小限変更 | 下位互換性、BaseToolHandler変更不要 |

## 技術スタック確定

- **言語**: Node.js 18+ (ESM)
- **非同期パターン**: Promise.all + async/await
- **ジョブ管理**: メモリ内Map（外部依存なし）
- **進捗共有**: オブジェクト参照
- **テスト**: Vitest（既存）
- **ロギング**: 構造化ログ（logger）

## 要明確化の解決

すべての技術的不明点が解決されました：
- ✅ バックグラウンド実行パターン決定
- ✅ ジョブ管理方式決定
- ✅ IndexWatcher統合方式決定
- ✅ 下位互換性維持方式決定

Phase 1 (設計＆契約) に進む準備完了。
