# 機能仕様書: Unity Editor内ターミナル

**機能ID**: `SPEC-3yfpxba7`
**作成日**: 2025-10-29
**ステータス**: 下書き
**入力**: Unity Editor内でターミナルウィンドウを開く機能

## ユーザーシナリオ＆テスト *(必須)*

### ユーザーストーリー1 - Workspace Rootでgit操作 (優先度: P1)

Unity開発者として、Workspace Root（リポジトリルート）でターミナルを開き、git commit、git push、npm操作をUnity Editorを離れずに実行したい。これにより、エディタとターミナルアプリケーション間の頻繁な切り替えを削減し、開発フローを中断せずにバージョン管理とパッケージ管理操作を実行できる。

**この優先度の理由**: git操作はUnity開発における最も頻繁なコマンドライン操作であり、この機能の主要価値提案である。エディタを離れずにcommit/pushできることで、開発者の生産性が大幅に向上する。

**独立テスト**: メニューから「Terminal (Workspace Root)」を開き、`git status`コマンドを実行して出力が表示されることで完全にテスト可能。これだけで基本的なターミナル機能の価値を提供できる。

**受け入れシナリオ**:

1. **前提** Unity Editorが開かれている、**実行** メニュー「Window > Unity MCP Server > Terminal (Workspace Root)」を選択、**結果** ターミナルウィンドウが開き、初期ディレクトリがワークスペースルート（.unity/config.jsonがある場所）である
2. **前提** Workspace Rootでターミナルが開いている、**実行** `git status`コマンドを入力、**結果** 現在のgitステータスが表示される
3. **前提** Workspace Rootでターミナルが開いている、**実行** `npm install`コマンドを入力、**結果** パッケージがインストールされ、進捗が表示される
4. **前提** Workspace Rootでターミナルが開いている、**実行** `git commit -m "message"`コマンドを入力、**結果** コミットが作成され、結果が表示される

---

### ユーザーストーリー2 - Project Rootでの作業 (優先度: P2)

Unity開発者として、Project Root（Unityプロジェクトルート）でターミナルを開き、Unityプロジェクト配下での作業を効率的に行いたい。これにより、Unity CLI操作やプロジェクト内のスクリプト実行をエディタから直接実行できる。

**この優先度の理由**: Unityプロジェクト固有の操作（Unity CLIビルド、Assets配下のスクリプト実行など）は、Workspace Root操作より頻度は低いが、プロジェクト作業においては重要な機能である。

**独立テスト**: メニューから「Terminal (Project Root)」を開き、`pwd`コマンドでUnityプロジェクトルート（Assets/ディレクトリがある場所）にいることを確認できる。

**受け入れシナリオ**:

1. **前提** Unity Editorが開かれている、**実行** メニュー「Window > Unity MCP Server > Terminal (Project Root)」を選択、**結果** ターミナルウィンドウが開き、初期ディレクトリがUnityプロジェクトルート（config.jsonのproject.rootで指定された場所）である
2. **前提** Project Rootでターミナルが開いている、**実行** `pwd`コマンドを入力、**結果** Unityプロジェクトルートのパスが表示される
3. **前提** Project Rootでターミナルが開いている、**実行** `ls Assets/`コマンドを入力、**結果** Assetsディレクトリの内容が表示される

---

### ユーザーストーリー3 - クロスプラットフォーム対応 (優先度: P1)

Unity開発者（Windows/macOS/Linux）として、各OS環境で適切なシェルが自動起動してほしい。これにより、OS環境に関係なく統一されたターミナル体験を得られ、チーム内の異なるOS利用者間での開発手順の共有が容易になる。

**この優先度の理由**: クロスプラットフォーム対応はUnity開発の基本要件であり、異なるOS間で一貫した開発体験を提供することは、チーム開発において不可欠である。

**独立テスト**: 各OS（Windows/macOS/Linux）でターミナルを開き、`echo $SHELL`（bash/zsh）または`$PSVersionTable`（PowerShell）でシェルタイプを確認できる。

**受け入れシナリオ**:

1. **前提** Windows環境でWSL2がインストールされている、**実行** ターミナルを開く、**結果** WSL2 Bashが起動し、Windowsパスが自動的にWSL2パス（/mnt/c/...）に変換されている
2. **前提** Windows環境でWSL2が未インストール、**実行** ターミナルを開く、**結果** PowerShellが起動する
3. **前提** macOS環境、**実行** ターミナルを開く、**結果** Zsh（または存在しない場合Bash）が起動する
4. **前提** Linux環境、**実行** ターミナルを開く、**結果** Bashが起動する
5. **前提** Windows WSL2環境でターミナルが開いている、**実行** `pwd`コマンドを入力、**結果** WSL2パス形式（/mnt/c/...）で現在ディレクトリが表示される

---

### ユーザーストーリー4 - 複数ターミナル起動 (優先度: P2)

Unity開発者として、複数のターミナルを同時に開き、並行して複数のコマンド実行やログ監視を行いたい。これにより、例えば1つのターミナルでサーバーを起動しながら、別のターミナルでgit操作を行うといった並行作業が可能になる。

**この優先度の理由**: 並行作業は開発効率を大きく向上させるが、単一ターミナルでも基本機能は実現できるため、優先度はP2とする。

**独立テスト**: ターミナルを2つ開き、それぞれで独立したコマンドを実行できることで確認可能。

**受け入れシナリオ**:

1. **前提** Unity Editorが開かれている、**実行** 「Terminal (Workspace Root)」を2回選択、**結果** 2つの独立したターミナルウィンドウが開く
2. **前提** 2つのターミナルが開いている、**実行** 1つ目で`git log`、2つ目で`npm test`を実行、**結果** 各ターミナルで独立してコマンドが実行され、出力が表示される
3. **前提** Unity Editorが開かれている、**実行** 「Terminal (Workspace Root)」と「Terminal (Project Root)」を1つずつ開く、**結果** 異なる初期ディレクトリを持つ2つのターミナルウィンドウが開く
4. **前提** 複数のターミナルが開いている、**実行** いずれか1つのターミナルウィンドウを閉じる、**結果** 他のターミナルは影響を受けず動作し続ける

---

### ユーザーストーリー5 - MCP経由でのターミナル制御 (優先度: P3)

AIエージェント（Claude Code等）として、MCPツール経由でターミナルを制御し、自動化されたコマンド実行やビルド処理を行いたい。これにより、AIが開発者に代わって複雑なコマンドシーケンスを実行できる。

**この優先度の理由**: MCP経由の制御は自動化における付加価値機能であるが、手動操作でも主要価値は実現できるため、優先度はP3とする。

**独立テスト**: MCPツール`terminal_open`を呼び出してセッションIDを取得し、`terminal_execute`でコマンドを実行、`terminal_read`で出力を取得できることで確認可能。

**受け入れシナリオ**:

1. **前提** Unity Editor MCPサーバーが起動している、**実行** MCPツール`terminal_open`を呼び出す（workingDirectory: "workspace"）、**結果** セッションIDが返却され、ターミナルウィンドウが開く
2. **前提** ターミナルセッションが開いている、**実行** MCPツール`terminal_execute`を呼び出す（sessionId, command: "git status"）、**結果** コマンドが実行される
3. **前提** ターミナルセッションでコマンドが実行された、**実行** MCPツール`terminal_read`を呼び出す（sessionId）、**結果** コマンド出力が返却される
4. **前提** ターミナルセッションが開いている、**実行** MCPツール`terminal_close`を呼び出す（sessionId）、**結果** セッションが終了し、ターミナルウィンドウが閉じる

---

### エッジケース

- ターミナル起動時に初期ディレクトリが存在しない場合、エラーメッセージを表示し、代わりにホームディレクトリで起動する
- WSL2がインストールされているが起動に失敗する場合、自動的にPowerShellにフォールバックする
- コマンド実行中にターミナルウィンドウを閉じた場合、バックグラウンドプロセスを適切に終了させる
- システムPATHが非常に長い（数千文字）場合でも、環境変数継承が正常に動作する
- 同時に10個以上のターミナルを開いた場合でも、各セッションが独立して動作する
- 非ASCII文字（日本語、絵文字等）を含むコマンド出力が正しく表示される
- WSL2環境でWindowsパスにスペースや日本語が含まれている場合、正しくWSL2パスに変換される

## 要件 *(必須)*

### 機能要件

- **FR-001**: システムはUnity Editorのメニュー「Window > Unity MCP Server > Terminal (Workspace Root)」から、ワークスペースルートを初期ディレクトリとしてターミナルウィンドウを開く必要がある
- **FR-002**: システムはUnity Editorのメニュー「Window > Unity MCP Server > Terminal (Project Root)」から、Unityプロジェクトルートを初期ディレクトリとしてターミナルウィンドウを開く必要がある
- **FR-003**: システムは複数のターミナルウィンドウを同時に開くことができ、各ウィンドウが独立したシェルセッションを持つ必要がある
- **FR-004**: システムはOS環境に応じて適切なシェルを自動選択する必要がある（Windows: WSL2 Bash優先→PowerShell、macOS: Zsh→Bash、Linux: Bash）
- **FR-005**: システムはUnity Editor起動時のシステム環境変数（特にPATH）を子プロセスに完全に継承する必要がある
- **FR-006**: システムはコマンド入力を受け付け、シェルに送信し、出力をターミナルウィンドウに表示する必要がある
- **FR-007**: システムはターミナルウィンドウのタイトルに、起動ディレクトリ名とセッションIDを表示する必要がある
- **FR-008**: システムはWindows環境でWSL2を使用する際、Windowsパスを自動的にWSL2パス（/mnt/c/...）に変換する必要がある
- **FR-009**: システムはMCPツール経由でターミナルを制御できる必要がある（`terminal_open`, `terminal_execute`, `terminal_read`, `terminal_close`）
- **FR-010**: システムはコマンド実行を非同期で行い、Unity Editorの動作をブロックしない必要がある
- **FR-011**: システムはターミナル出力をプレーンテキストとして表示する必要がある（基本的なANSIエスケープコード色対応は含む）
- **FR-012**: システムは既存のメニュー「Unity Editor MCP」を「Unity MCP Server」に統一する必要がある

### 主要エンティティ

- **ターミナルセッション**: 1つのシェルプロセスインスタンスを表し、一意のセッションID、初期ディレクトリ、シェルタイプ、実行中ステータスを持つ
- **ターミナルウィンドウ**: Unity EditorWindow として表示されるUI要素で、1つのターミナルセッションに対応し、コマンド入力フィールドと出力表示エリアを持つ
- **シェルプロセス**: OSのシェル実行ファイル（bash, zsh, pwsh, wsl.exe）のプロセスインスタンスで、標準入力/出力/エラーストリームを通じて通信する
- **パス解決**: ワークスペースルート（.unity/config.jsonがあるディレクトリ）とプロジェクトルート（config.jsonのproject.root）を解決するロジック

---

## スコープ外 *(オプション)*

以下の機能は本仕様のスコープ外とし、将来のバージョンで対応予定:

- PTY（疑似ターミナル）対応によるインタラクティブプログラム（vim, less, top等）のサポート
- 完全なANSIエスケープシーケンス対応（256色、カーソル移動、画面クリア等）
- ターミナルセッションの永続化（Unity Editor再起動後の復元）
- コマンド履歴機能（上下キーでの履歴ナビゲーション）
- タブ補完機能
- WSL2ディストリビューションの手動選択（デフォルト以外のディストリビューション指定）
- ターミナル出力の検索機能
- ターミナル出力のファイルへのエクスポート
- カスタムシェル設定ファイル（.bashrc, .zshrc等）の自動ロード

---

## 技術制約 *(該当する場合)*

- PTY（疑似ターミナル）は未対応のため、インタラクティブプログラム（vim, less, top等）は正常に動作しない
- ANSIエスケープコードは基本的な色（8色）のみ対応し、複雑な制御シーケンスは未対応
- Windows環境でのWSL2サポートはデフォルトディストリビューションのみ対応
- Unity Editor環境での制約により、シェルプロセスとの通信は標準入出力ストリームのみを使用
- 非同期I/O処理はUnity EditorのメインスレッドUpdateループ内で処理されるため、極端に高頻度な出力には遅延が発生する可能性がある

---

## 前提条件 *(該当する場合)*

この機能は以下を前提とします:

- Unity Editorが正常に起動している
- .unity/config.jsonファイルがワークスペース内に存在し、project.rootが正しく設定されている
- システムにシェル実行ファイル（bash, zsh, pwsh, cmd.exe, wsl.exe）が少なくとも1つインストールされている
- Unity Editor起動時にシステム環境変数PATHが設定されている
- Windows環境でWSL2を使用する場合、WSL2がインストールされ、デフォルトディストリビューションが設定されている

---

## 依存関係 *(該当する場合)*

この機能は以下に依存します:

- Unity Editor（EditorWindow API）
- .NET System.Diagnostics.Process（シェルプロセス起動とI/O管理）
- .unity/config.json（ワークスペースとプロジェクトルートの解決）
- Unity MCP Server の既存通信インフラストラクチャ（Node側MCPツールとUnity側ハンドラ間の通信）

---

## 成功基準 *(必須)*

以下の成功基準を満たす必要があります:

1. ユーザーは「Terminal (Workspace Root)」メニューから3クリック以内でワークスペースルートのターミナルを開くことができる
2. ユーザーは「Terminal (Project Root)」メニューから3クリック以内でプロジェクトルートのターミナルを開くことができる
3. Windows WSL2環境、macOS環境、Linux環境のそれぞれで、適切なシェルが自動起動し、gitコマンドとnpmコマンドが実行可能である
4. ユーザーは同時に5つ以上のターミナルウィンドウを開き、各ウィンドウで独立したコマンド実行ができる
5. コマンド出力が1秒以内にターミナルウィンドウに表示される（通常のコマンド出力量の場合）
6. システムPATH上に存在するすべてのコマンド（git, npm, python等）がターミナルから実行可能である
7. WSL2環境でWindowsパス（C:\...）がWSL2パス（/mnt/c/...）に自動変換され、pwdコマンドで正しいパスが表示される
8. 既存のメニュー項目がすべて「Unity MCP Server」配下に統一されている

**成功基準ガイドライン**:

成功基準は以下の条件を満たす必要があります:

1. **測定可能**: 具体的な指標を含む（時間、パーセンテージ、カウント、レート）
2. **技術に依存しない**: フレームワーク、言語、データベース、ツールに言及しない
3. **ユーザー重視**: システム内部ではなく、ユーザー/ビジネスの視点から結果を説明
4. **検証可能**: 実装の詳細を知らなくてもテスト/検証できる

---

## ⚡ クイックガイドライン

- ✅ ユーザーが「何を」必要とし「なぜ」必要なのかに焦点を当てる
- ❌ 「どのように」実装するかを避ける (技術スタック、API、コード構造なし)
- 👥 ビジネス関係者向けに記述 (開発者向けではない)
